#!/usr/bin/python
# -*- coding: utf-8 -*-

###############################
# Yet another dotfiles script #
###############################

import argparse, fnmatch, json, platform, re, shutil, sys
from os import listdir, symlink, unlink
from os.path import abspath, exists as path_exists, expanduser, isdir, isfile, islink, join, realpath, relpath

_DFROOT_ENV_VAR = "DOTFILES_DIR"
_DFRC = ".dotfilesrc"

# Quick utility functions


def zerono(count):
	return count if count else "no"

def zeroNo(count):
	return count if count else "No"

def s(count, pluralzero):
	return "s" if count > 1 or (not count and pluralzero) else ""

def do(desc, func, *func_args, **func_kwargs):
	if not args.simulate:
		info(desc)
		func(*func_args, **func_kwargs)
	else:
		say(desc)

def find_dfroot():
	dnre = re.compile("^\.?dot[^a-zA-Z]?files$", re.IGNORECASE)
	home = expanduser("~")

	for f in listdir(home):
		canonical = join(home, f)
		if isdir(canonical) and dnre.match(f):
			return canonical
	return None

def enumerate(source_root, target_root, dfrc, full_recursion=True):
	"""
	Returns of list of tuple ( source (str), target (str), ignore (bool), ignored_reason (tuple), status (str )
	Status can be:
	ok		
	#		Normal state: Either the source should be linked and is, or it shouldn't and isn't.
	ok_dirs	
	#		Normal state : Target is not link to source, but target and source are directories. 
	#		This is an acceptable state.
	ignored_linked
	#		Something is linked that should have been ignored.
	broken_link
	#		Source should be linked and isn't, there's a broken link with the expected name.
	broken_link_to_ignored
	#		There's a broken link where an ignored file would be linked.
	conflict
	#		Source is not a directory, should be linked, but there's something else at target.

	Storing source and target is pointless with thez current configuration possibilies, but may allow to include externals
	(ie, configuration commands that would not )
	"""
	def do_enumerate(source_pos, target_pos, ignore_all=False, ignored_reason=None):
		files = list()
		source_can = join(source_root, source_pos)
		finest("Scanning {0}".format(source_can))
		for f in listdir(source_can):
			# Relative paths
			source_rel = join(source_pos, f) 
			target_rel = join(target_pos, f)
			# Absolute paths
			source_abs = realpath(abspath(join(source_root, source_rel))) # We must use realpath here : the dotfiles repo
			# may contain internal symlinks (the sparkup vim plugin does) which would trigger conflict status if we didn't
			# resolve them first.
			target_abs = abspath(join(target_root, target_rel))
			ignore_this = False or ignore_all

			# Recursively processing ignored directories is needed to allow
			# checking for ignored files that happens to have been linked.

			if not ignore_this:
			# Process ignore rules
			# Note on fnmatch: it behaves!
			# It will match some_dir/file.txt on *.txt, but not on file.txt
				for i in dfrc["ignore"]:
					if fnmatch.fnmatch(source_rel, i):
						fine("Ignoring {0}".format(source_rel))
						ignore_this = True
						ignored_reason = ( "ignore_rule", i)
						break

			if not ignore_this:
			# Process other rules
			# Wording inconsistency warning: 
			#	a rule's "target" is what it is applied on, ie "source" locations!!!
				for r in dfrc["rules"]:
					if fnmatch.fnmatch(source_rel, r["target"]):
						if "platforms" in r:
							if not this_platform in r["platforms"]:
								notice("Skipping {0}".format(source_rel))
								ignore_this = True
								ignored_reason = ("platform_rule", i)

			# Compute status
			if path_exists(target_abs): # If target path exists
				if abspath(realpath(target_abs)) == source_abs:
					# If the source is ignored but found linked to target, it is a conflict 
					# iff the target is an explicit link (ignored files may reside in linked dirs).
					status = "ignored_linked" if ignore_this and islink(target_abs) else "ok"
				else: # If target exists but is not a link to source.
					if ignore_this:
						status = "ok"
					else:
						# This is a conflict ONLY if source is not a directory that is not explicitely a link.
						# We don't necessary want to link directories: when managing OSX config files, we may
						# have a DOTFILES/Library that must *not* replace the default ~/Library
						status = "ok_dirs" if isdir(target_abs) and not islink(target_abs) else "conflict"
			else: # If target path DOES NOT exist
				if islink(target_abs): # If we have a broken path
					status = "broken_link_to_ignored" if ignore_this else "broken_link"
				else: # If there's really nothing
					status =  "ok" if ignore_this else ( "unlinked_dir" if isdir(source_abs) else "unlinked" ) 

			# Append to list
			files.append( ( source_abs, target_abs, ignore_this, ignored_reason if ignore_this else None, status) )

			# Unless full_recursion==True, we don't go further if we're ignoring this, if this is properly linked or
			# an unlinked dir
			if isdir(source_abs) and ( not (ignore_this or status in ( "ok", "unlinked_dir" ) ) or full_recursion):
				finest("Recursing in [{1}/{2}] {0}".format(source_abs, "ignored" if ignore_this else "syncing", status))
				files.extend( do_enumerate(source_rel, target_rel, ignore_this, ignored_reason) )
		return files

	say("Reading files from {0}...".format(source_root))
	return do_enumerate("", "")

def command_sync(source_root, target_root, args, dfrc):
	files = enumerate(source_root, target_root, dfrc, full_recursion=args.unlink)
	say("Synchronizing files...")
	
	linked = 0
	unlinked = 0
	deleted_files = 0
	deleted_trees = 0

	for source, target, ignored, ignore_reason, status in files:
		if status == "ok":
			continue
		if status in ( "unlinked", "unlinked_dir" ) :
			if not path_exists( target ):
				do("Symlink\t{0} => {1}".format(source, target), symlink, source, target)
				linked += 1
		elif status in ( "ignored_linked", "broken_link_to_ignored", "broken_link" ) and args.unlink:
			if path_exists(target):	
				do("Unlink\t{0}".format(target), unlink, target)
				unlinked += 1
		elif status is "conflict" and args.force:
			if path_exists(target):
				if isdir(target):
					deleted_trees += 1
					do("DELETE\t{0}".format(target), shutil.rmtree, target)
				else:
					deleted_files+=1
					do("DELETE\t{0}".format(target), unlink, target)

	say("{0} new link{1}.\n{2} link{3}, {4} file{5} and {6} directory tree{7} were removed.".format(
		zeroNo(linked), s(linked, True),
		zeroNo(unlinked), s(unlinked, True),
		zerono(deleted_files), s(deleted_files, True),
		zerono(deleted_trees), s(deleted_trees, True)
		))

1

def command_add(source_root, target_root, args, dfrc):
	pass

def command_remove(source_root, target_root, args, dfrc):
	pass

def command_status(source_root, target_root, args, dfrc):
	files = enumerate(source_root, target_root, dfrc, True)

	abnormal = 0
	ok = 0
	for source, target, ignored, ignore_reason, status in files:
		if not status in ( "ok", "ok_dirs" ):
			abnormal += 1
			status = status + " "*(16-len(status))
			say("{0}{1}".format(status, relpath(source, source_root)))
		else:
			ok+=1

	say("{0} problem{1} found.".format(abnormal if abnormal else "Not a single", s(abnormal)))
	say("{0} correctly synced file{1}.".format(ok, "s" if ok>1 else ""))

	return abnormal
	
	#print(status(source, target, files))
	#for f in status(source, target, files):
		#print("{0} => {1} : {2}".format(f[0][0], f[0][1], f[1]))

def make_print(enabled=True, template="{0}"):
	if enabled:
		def ret(msg):
			print(template.format(msg))
	else:
		def ret(msg):
			pass
	return ret

if __name__ == "__main__":

	# Parsing command-line arguments
	parser = argparse.ArgumentParser(description='Synchronize dotfiles.', formatter_class=argparse.ArgumentDefaultsHelpFormatter)

	subparsers = parser.add_subparsers(help='Commands', metavar="command", dest="cmd")
	parser.add_argument('-f', "--from", dest="from_dir", metavar="dotfiles_dir", action='store', nargs=1, default=find_dfroot(), help="directory where dotfiles are stored")
	parser.add_argument('-t', "--to", dest='to_dir', metavar="target_dir", action='store', nargs=1, default=expanduser("~"), help="directory where dotfiles are stored")
	
	parser.add_argument("--dry-run", dest='simulate', action='store_const', const=True, default=False, help="Simulate only")

	verbosity_group = parser.add_mutually_exclusive_group()
	verbosity_group.add_argument('-v', dest='verbosity', action='count', default=1, help="Increase verbosity (-vvv for ultra verbose)")
	verbosity_group.add_argument('-q', dest='verbosity', action='store_const', const=0, help="Disable output")

	# Parser for sync command
	parser_sync = subparsers.add_parser("sync", help="synchronize dotfiles")
	parser_sync.add_argument("--unlink", dest="unlink", action="store_const", const=True, default=False, help="Unlink ignored files if needed")
	parser_sync.add_argument("--force", dest="force", action="store_const", const=True, default=False, help="Replace existing files")

	parser_add = subparsers.add_parser("add", help="add files or directories to the repository")
	parser_remove = subparsers.add_parser("remove", help="stop tracking files or repositories")
	parser_status = subparsers.add_parser("status", help="print synchronization status")

	args = parser.parse_args()

	# Generate print functions
	finest = make_print(args.verbosity>=4)
	fine = make_print(args.verbosity>=3)
	info = make_print(args.verbosity>=2)
	say = make_print(args.verbosity)
	fatal = make_print(args.verbosity)

	finest("Maximum verbosity")

	dfroot = args.from_dir
	target = expanduser(args.to_dir)

	# Sanity checks

	if not dfroot:
		fatal("Can't determine location of source directory. Please pass it with -f PATH.")
		exit(-1)

	if not target:
		fatal("Can't determine location of target directory. Please pass it with -t PATH.")
		exit(-1)

	if not isdir(dfroot):
		fatal("Source directory doesn't exist or is not a directory.")
		exit(-1)

	if not isdir(target):
		fatal("Target directory doesn't exist or is not a directory.")
		exit(-1)

	info("Working with \"{0}\" syncing with \"{1}\".".format(dfroot, target))

	# Get the current platform
	this_platform = platform.system()
	platform_translations = {"Darwin": "Mac"} # Use more common names
	if this_platform in platform_translations.keys():
		this_platform = platform_translations[this_platform]

	# Read _DFRC if it exists
	dfrc = join(dfroot, _DFRC)
	# Empty base
	rcdata = {
			"ignore": [],
			"rules": []
	}

	if path_exists(dfrc) and isfile(dfrc):
		fine("Reading {0}".format(dfrc))
		with open(dfrc, "r") as dfrc_f:
			rcdata.update(json.load(dfrc_f))

exit({
	"sync": command_sync,
	"status": command_status,
	"add": command_add,
	"remove": command_remove
 }[args.cmd](dfroot, target, args, rcdata))
